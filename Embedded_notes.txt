TODO:
-----
[X] Investigate why watermarks give strange numbers
[] Wrapper around dtostrf() (which is valid only for Arduino)
[] Serial get stuff (receive values and store in serial_port.cpp output)
[X] Vimspector and platformio
[] Library with LPF, PRBS generator, etc.
[X] Setup a github private repo
[] SPI and LCD display
[] Voltage limiters
[] Change curve characteristics
[] Reentrant libraries
[] C-files docs
[] Interrupt example
[] UART interrupt example

- DOCS
    - Graphs, dependencies, etc.
    - hw_config first, what is that
    - List of each components: first <component>_init(), then
      <component>_main().
    - prefix_ for component signals
    - Guideline to add a new component (don't forget to schedule it!)
    - How to search to who produce and who consumes all the outputs (:vimgrep
      /{seto_, geto}/ **/*.cpp)
    - Doxgen?
    - copy .clang_tidy from somewhere

STM32 HOW TO:
    -CMSIS is a wrapper around FreeRTOS, so you can just call the FreeRTOS
    API directly

    ===================
    = CubeMX settings =
    ===================
    - Adjust the pins as usual. To see the board pinout just google it.
    - FreeRTOS. Select CMSIS_V2, but then go to Sys and in Timebase Source
      deselect SysTick.
    - Generate the project (.ioc file etc) with MX.
        - In Project -> Project Manager -> Project
          - select "Toolchain/IDE: Makefile"
        - In Project -> Project Manager -> Code generator
          - Select "Copy all used libraries into the project folder"
          - Select "Generate peripheral initialization as pairs of '.c/.h' per
            peripheral
        => It will generate all the files including a Makefile that needs some
        tweak
    - Edit the main.c file to remove the default task, add void
      tasks_setup(void) prototype and to call it in the main.
    - If you want to use vanilla FreeRTOS, then read below.

    *** UPDATE CUBE PROJECT ***
    Copy the Makefile from an existing project and use a diff tool! Basically
    you have to specify the C_SOURCES files, the INCLUDE paths and the
    GCC_PATH and define your own targets.

    =====================
    = Makefile tweaking =
    =====================
    What to do in the generated Makefile from MX.
    - Add
        ifeq ($(OS),Windows_NT)
        	SERIAL_PORT = "TBD"
        	ARM_NONE_EABI_PATH = "C:/ST/STM32CubeIDE_1.14.1/STM32CubeIDE/plugins/com.st.stm32cube.ide.mcu.externaltools.gnu-tools-for-stm32.11.3.rel1.win32_1.1.100.202309141235/tools"
        	GCC_PATH = $(ARM_NONE_EABI_PATH)/bin
        	PROGRAMMER_PATH = "C:/ST/STM32CubeIDE_1.14.1/STM32CubeIDE/plugins/com.st.stm32cube.ide.mcu.externaltools.cubeprogrammer.win32_2.1.100.202311100844/tools/bin"
        	PROGRAMMER = $(PROGRAMMER_PATH)/STM32_Programmer_CLI

        else
        	SERIAL_PORT = /dev/cu.usbmodem103
        	ARM_NONE_EABI_PATH =/Applications/STM32CubeIDE.app/Contents/Eclipse/plugins/com.st.stm32cube.ide.mcu.externaltools.gnu-tools-for-stm32.11.3.rel1.macos64_1.1.100.202310310803/tools/
        	GCC_PATH = $(ARM_NONE_EABI_PATH)/bin
        	PROGRAMMER_PATH = /Applications/STMicroelectronics/STM32CubeProgrammer.app/Contents/MacOs/bin
        	PROGRAMMER = $(PROGRAMMER_PATH)/STM32_Programmer_CLI
        endif


        # Source code files
        # Ubaldo
        C_SOURCES += application/application_setup.c
        C_SOURCES += $(wildcard platform/src/*.c)
        C_SOURCES += $(wildcard application/**/*.c)

        # Includes files (don't forget the \ at the end of the line before -Icomponents

        # Ubaldo
        # OBS! You may need other include hidden somewhere in ARM_NONE_EABI_PATH
        C_INCLUDES += -I$(ARM_NONE_EABI_PATH)/arm-none-eabi/include
        C_INCLUDES += -I$(ARM_NONE_EABI_PATH)/arm-none-eabi/include/newlib-nano
        C_INCLUDES += -I$(ARM_NONE_EABI_PATH)/lib/gcc/arm-none-eabi/11.3.1/include
        C_INCLUDES += -Iplatform/inc
        C_INCLUDES += -Iapplication

        # Add the following targets
        #######################################
        # clean up
        #######################################
        build_flash:
        	make clean && make -j9 all && make upload

        clean:
        	-rm -fR $(BUILD_DIR)

        compiledb:
        	compiledb make -j9

        upload:
        	$(PROGRAMMER) --connect port=SWD mode=UR reset=HWrst -d ./build/$(TARGET).bin 0x08000000  --verify -g

        monitor:
	        screen /dev/cu.usbmodem103 115200,cs8,-parenb,-cstopb

        # Set default target
        .DEFAULT_GOAL := build_flash

    =========
    = DEBUG =
    =========
      - Using OPEN OCD, between the gdb debugging tool and the st-link debug
      adapter. To make openocd to work, we need

        a) the target platform (e.g. stm32fx.cfg)
        b) the used probe (e.g. stlink.cfg)

      Both the files come with the openocd installation and they are placed in
      a script named openocd_<target>_<probe>.sh. You must source this file
      with:

        source openocd_stm32fx_stlink.sh

      The above will setup the openocd server.

      Next, we have to connect with a client (gdb through Termdebug in Vim).
      Note that we need arm-wabi-none-gdb!!!
      Open another shell window and run

        arm-none-eabi-gdb -x ../gdb_commands_init.txt

      So, at the end you will have two shells running: one with the openocd
      server and the other with gdb. If you use Windows use MYGW64.

      To use Termdebug you must run with Termdebug <filename>.elf and once
      started you always have to run

         (gdb)target extended-remote localhost:3333
         (gdb)monitor stm32f4x.cpu configure -rtos auto
         (gdb)monitor reset init
         (gdb)monitor reset

     "monitor" send the commands directly to openocd so the syntax is monitor
     <openocd_command>.
     But these are included in a gdb_init_commands.txt file that is called
     upon aperture of Termdebug.
     To find out the target (in the above case is stm32f4xx.cpu), run "monitor
     targets" and read the output.

     OBS! Due to a bug in Termdebug it is not possible to display the output
     of openocd in vim. For that, you must open arm-eabi-none-gdb in a new
     terminal window.

     Here is a tool: https://github.com/1udo6arre/svd-tools that is nice to use
     I prepared a Vim function such that automate all of the above.
     The openocd server is run inside Vim. It is automatically shutoff when
     Termdebug is closed thanks to an autocommand.

     In reality you could do a lot more with openocd, search for How to use
     the GDB (Gnu Debugger) and OpenOCD for microcontroller debugging - from
     the terminal? on StackOverflow.

      ------------------------
      If things go wrong, then create a new CubeIDE project starting from the .ioc
      file generated by MX, copy all the source code, add all the include paths
      in Project->Properties-> C/C++ Build -> MCU GCC Compiler -> Include
      paths, etc. build and debug.

    ==================
    = Serial monitor =
    ==================
    I am using screen.
    To close it <c-a>k.

    ====================
    = Vanilla FreeRTOS =
    ====================
    You can, but it is messy! All the steps below are automatically handled by
    Cube.
    1. Copy FreeRTOS/Source distribution folder in your local project folder
    2. You must select only what is needed:
      - In portable/ remove everything but GCC and MemMang
        - portable/GCC/<your target> (remove all the rest)
        - MemMang: you can carry everything but you pick only what you want
    3. If any, remove Src/sysmem.c
    4. Some interrupts are handled by FreeRTOS, so we must disable them from
    CubeMX
        - Do not use Subpriorities
        - Set the Priority to a value > 0 (this value must be higher than what
          you have in configMAX_SYSCALL_INTERRUPT...
        - Disable the following interrupts
          1. System service call via SWI instruction
          2. Pendable request for system service
          3. System tick timer
        Note that you cannot disable the Call HAL handler of System tick
        handler, hence, you must add the following to the configFreeRTOS.h
        file:
            #define xPortSysTickHandler SysTick_Handler
        - Then, if you have a vApplicationGetIdleTaskMemory() error,
          #define configSUPPORT_STATIC_ALLOCATION 0 or
          configKERNEL_PROVIDED_STATIC_MEMORY to 1.
    5. Put the configFreeRTOS.h file in Core/Inc

Guidelines
----------
Create a new component:
    - Copy blink example and edit it.
    - in the .h file you only have have *_init(), *_main() and all the geto_*.
	- The *_init() and the *_main() must be added to tasks_config.cpp.
	- the geto_* are used by all the components that consume such output.
	- OBS! check the sizeof() thing in the seto_ geto_ methods!

Monitoring:
    - I use a tool named "serialplot" that I compiled by myself for macos.

Memory management with Arduino:
https://docs.arduino.cc/learn/programming/memory-guide

Troubleshooting:
----------------
Q: (Platformio) clangd won't find stuff
A1: platformio.ini must contain

  build_flags = --target=avr

when building the compile_commands.json file. Then, you have to remove it.

A2: check that the geto_ and seto_ methods have exactly the same name
everywhere. Copy
and search that copied value to check if you forgot any underscore, etc.

Q: Linker misses references:
A: check that the geto_ and seto_ methods have exactly the same name
everywhere. Copy
and search that copied value to check if you forgot any underscore, etc.

Q: Arduino RAM is too little.
A: use Flash instead of SRAM. How?
  - Wrap strings to be sent to Serial.print with F()
  - Use "const PROGMEM int pippo;" (AVR), or "static const int pippo" (for ARM).

Q: the compile_commands.json is empty
R: you must build with target all. Try make clean first.

---------------------------------------------------------------------------

STM32 platformio or stand-alone (OLD AND MESSY, DROP IT):
    - Plaformio copies the "always the same files" (Middleware, Drivers, etc)
      in .platformio/somewhere. Hence, you only have to copy the Core files
      that are specific to your project - typically just main.c and main.h. However, not that the
      Middleware/Drivers from platformio may be old.
    - For this reason, it might be better to use their IDE or generate the
      project files and import them in VSCode.
    - Or, you edit the files with Vim while working into workspace/your
      project, so you are sure that all the files are there (but what about
      the compile_commands.json?)
    - STM32 and Freertos how to: https://hesimsek.com/blog/2022/10/26/stm32-freertos-config-without-cmsis/

    ... or alternatively:

    CMSIS-RTOS API is just wrapped around the FreeRTOS API.
    Here is what I did: I enabled FreeRTOS in CubeMX, then I simply included the FreeRTOS header files and used its functions.
    This has a bit of compilation overhead (useless source code gets compiled anyway), but it works.
